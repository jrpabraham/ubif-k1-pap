for (i in 1:numhyp) {
EST[i, 1] <- model$test$coefficients[i]
EST[i, 2] <- model$test$tstat[i]
EST[i, 3] <- model$test$sigma[i]
EST[i, 4] <- model$test$pvalues[i]
}
colnames(EST) <- c("Estimate", "Tstat", "SE", "P")
return(EST)
}
## PermTest returns MC approximations of the exact p-value ##
PermTest <- function(equation, treatvars, clustvars, hypotheses, iterations, data) {
stopifnot(length(hypotheses) <= 1)
obsEST <- RegTest(equation, clustvars, hypotheses, data)
obsStat <- obsEST[1, 2]
simEST <- matrix(ncol = 4)
for (i in 1:iterations) {
simTreat <- data[, treatvars, drop = FALSE]
simTreat <- simTreat[sample(nrow(simTreat)),]
simData <- cbind(simTreat, data[, !(names(data) %in% treatvars), drop = FALSE])
colnames(simData)[1:2] <- treatvars
simEST <- rbind(simEST, RegTest(equation, clustvars, hypotheses, data = simData))
}
simSTAT <- simEST[2:nrow(simEST), 2]
countSTAT <- matrix(abs(simSTAT) >= abs(obsStat), ncol = 1)
ExactP <- matrix(1, nrow = 1, ncol = nrow(countSTAT)) %*% countSTAT
ExactP <- ExactP / iterations
EST <- cbind(obsEST, ExactP)
colnames(EST) <- c("Estimate", "Tstat", "SE", "P", "ExactP")
return(EST)
}
## FDR returns minimum q-values ##
FDR <- function(pvals, step) {
if (sum(is.na(pvals) == FALSE) <= 1) {return(pvals)}
if (missing(step)) {step <- 0.001}
allpvals <- cbind(as.matrix(pvals), matrix(1:nrow(as.matrix(pvals)), ncol = 1))
pvals <- na.omit(allpvals)
nump <- nrow(pvals)
pvals <- pvals[order(pvals[, 1]), ]
rank <- matrix(1:nump, ncol = 1)
pvals <- cbind(pvals, rank, matrix(0, nrow = nump, ncol = 1))
qval <- 1
while (qval > 0) {
qfirst <- qval / (1 + qval)
fdrtemp <- (qfirst * rank) / nump
subrank <- which(fdrtemp >= as.matrix(pvals[, 1]))
if (length(subrank) < 1) {
numreject <- 0
} else numreject <- max(subrank)
qsec <- qfirst * (nump / (nump - numreject))
fdrtemp <- (qsec * rank) / nump
subrank <- which(fdrtemp >= as.matrix(pvals[, 1]))
if (length(subrank) < 1) {
numreject <- 0
} else numreject <- max(subrank)
pvals[which(pvals[, 3] <= numreject), 4] <- qval
qval <- qval - step
}
pvals <- pvals[order(pvals[, 2]), ]
qvals <- matrix(nrow = nrow(allpvals), ncol = 1)
qvals[match(pvals[, 2], allpvals[, 2]), 1] <- pvals[, 4]
return(as.matrix(qvals))
}
################
## Clean data ##
################
## Create locals for simulation ##
OBS <- 510
## Generate treatment ##
Treat <- sample(0:2,OBS, rep = TRUE, prob = c(.33, .33, 0.33)) %>%
factor(levels = c(0, 1, 2), labels = c("Poverty", "Ind.", "Col."))
Pov <- (Treat == "Poverty") * 1
Ind <- (Treat == "Ind.") * 1
Col <- (Treat == "Col.") * 1
## Generate gender ##
Gen <- sample(0:1,OBS,rep = TRUE,prob = c(.5,.5))  %>%
factor(levels = c(0,1), labels = c("Male","Female"))
## Generate factor variable measuring highest level of education ##
Edu <- sample(1:3,OBS,rep = TRUE,prob = c(.5,.3,.2)) %>%
factor(levels = c(1,2,3), labels = c("Primary school","High school","University & above"))
## Generate income ##
LnInc <- rnorm(OBS, mean = 5, sd = 1)
Inc <- exp(LnInc)
## Generate y with notreatment effect ##
yNull <- rnorm(OBS, 0, 1)
## Generate outcome with effects
yInd <- (0.8 * Ind) + rnorm(OBS, 0, 1)
yCol <- (0.4 * Col) + rnorm(OBS, 0, 1)
## Generate id ##
ID <- matrix(1:OBS, ncol = 1)
## Create, save dataframe ##
TestData <- data.frame(ID, Treat, Pov, Ind, Col, Gen, Edu, Inc, yNull, yInd, yCol)
################
## Estimation ##
################
## Plain OLS ##
hypotheses <- c("Ind = 0", "Col = 1", "Ind - Col = 0")
equations <- c("yNull ~ Ind + Col", "yInd ~ Ind + Col", "yCol ~ Ind + Col")
for (h in hypotheses) {
RES <- matrix(nrow = 1, ncol = 5)
for (eqn in equations) {
# RES <- rbind(RES, RegTest(eqn, clustvars = TestData$ID, hypotheses = c(h), data = TestData))
RES <- rbind(RES, PermTest(eqn, treatvars = c("Treat"), clustvars = TestData$ID, hypotheses = c(h), iterations = 100, data = TestData))
}
RES <- RES[2:nrow(RES), 1:ncol(RES)]
RES <- cbind(RES, FDR(RES[, 4]))
rownames(RES) <- equations
colnames(RES)[6] <- "Min. Q"
print("--------------------------------------------------------------------", quote = FALSE)
print(paste("H_0:", h), quote = FALSE)
print(RES, quote = FALSE)
print("--------------------------------------------------------------------", quote = FALSE)
}
##############################
## Install missing packages ##
##############################
this.dir <- dirname(parent.frame(2)$ofile) # frame(3) also works.
setwd(this.dir)
set.seed(47269801)
required.packages <- c("dplyr", "multiwayvcov", "multcomp", "knitr", "rprojroot")
packages.missing <- required.packages[!required.packages %in% installed.packages()[,"Package"]]
if(length(packages.missing) > 0) {install.packages(required.packages, repo="https://cran.cnr.berkeley.edu/")}
lapply(required.packages, library, character.only = TRUE)
######################
## Define functions ##
######################
## RegTest conducts asymptotic test from linear model ##
RegTest <- function(equation, clustvars, hypotheses, data) {
model <- lm(equation, data = data, na.action = na.omit)
if (missing(clustvars)) model$vcov <- vcov(model)
else model$vcov <- cluster.vcov(model, cluster = clustvars)
model$test <- summary(glht(model, linfct = hypotheses, vcov = model$vcov))$test
numhyp <- length(hypotheses)
EST <- matrix(nrow = numhyp, ncol = 4)
for (i in 1:numhyp) {
EST[i, 1] <- model$test$coefficients[i]
EST[i, 2] <- model$test$tstat[i]
EST[i, 3] <- model$test$sigma[i]
EST[i, 4] <- model$test$pvalues[i]
}
colnames(EST) <- c("Estimate", "Tstat", "SE", "P")
return(EST)
}
## PermTest returns MC approximations of the exact p-value ##
PermTest <- function(equation, treatvars, clustvars, hypotheses, iterations, data) {
stopifnot(length(hypotheses) <= 1)
obsEST <- RegTest(equation, clustvars, hypotheses, data)
obsStat <- obsEST[1, 2]
simEST <- matrix(ncol = 4)
for (i in 1:iterations) {
simTreat <- data[, treatvars, drop = FALSE]
simTreat <- simTreat[sample(nrow(simTreat)),]
simData <- cbind(simTreat, data[, !(names(data) %in% treatvars), drop = FALSE])
colnames(simData)[1:2] <- treatvars
simEST <- rbind(simEST, RegTest(equation, clustvars, hypotheses, data = simData))
}
simSTAT <- simEST[2:nrow(simEST), 2]
countSTAT <- matrix(abs(simSTAT) >= abs(obsStat), ncol = 1)
ExactP <- matrix(1, nrow = 1, ncol = nrow(countSTAT)) %*% countSTAT
ExactP <- ExactP / iterations
EST <- cbind(obsEST, ExactP)
colnames(EST) <- c("Estimate", "Tstat", "SE", "P", "ExactP")
return(EST)
}
## FDR returns minimum q-values ##
FDR <- function(pvals, step) {
if (sum(is.na(pvals) == FALSE) <= 1) {return(pvals)}
if (missing(step)) {step <- 0.001}
allpvals <- cbind(as.matrix(pvals), matrix(1:nrow(as.matrix(pvals)), ncol = 1))
pvals <- na.omit(allpvals)
nump <- nrow(pvals)
pvals <- pvals[order(pvals[, 1]), ]
rank <- matrix(1:nump, ncol = 1)
pvals <- cbind(pvals, rank, matrix(0, nrow = nump, ncol = 1))
qval <- 1
while (qval > 0) {
qfirst <- qval / (1 + qval)
fdrtemp <- (qfirst * rank) / nump
subrank <- which(fdrtemp >= as.matrix(pvals[, 1]))
if (length(subrank) < 1) {
numreject <- 0
} else numreject <- max(subrank)
qsec <- qfirst * (nump / (nump - numreject))
fdrtemp <- (qsec * rank) / nump
subrank <- which(fdrtemp >= as.matrix(pvals[, 1]))
if (length(subrank) < 1) {
numreject <- 0
} else numreject <- max(subrank)
pvals[which(pvals[, 3] <= numreject), 4] <- qval
qval <- qval - step
}
pvals <- pvals[order(pvals[, 2]), ]
qvals <- matrix(nrow = nrow(allpvals), ncol = 1)
qvals[match(pvals[, 2], allpvals[, 2]), 1] <- pvals[, 4]
return(as.matrix(qvals))
}
################
## Clean data ##
################
## Create locals for simulation ##
OBS <- 510
## Generate treatment ##
Treat <- sample(0:2,OBS, rep = TRUE, prob = c(.33, .33, 0.33)) %>%
factor(levels = c(0, 1, 2), labels = c("Poverty", "Ind.", "Col."))
Pov <- (Treat == "Poverty") * 1
Ind <- (Treat == "Ind.") * 1
Col <- (Treat == "Col.") * 1
## Generate gender ##
Gen <- sample(0:1,OBS,rep = TRUE,prob = c(.5,.5))  %>%
factor(levels = c(0,1), labels = c("Male","Female"))
## Generate factor variable measuring highest level of education ##
Edu <- sample(1:3,OBS,rep = TRUE,prob = c(.5,.3,.2)) %>%
factor(levels = c(1,2,3), labels = c("Primary school","High school","University & above"))
## Generate income ##
LnInc <- rnorm(OBS, mean = 5, sd = 1)
Inc <- exp(LnInc)
## Generate y with notreatment effect ##
yNull <- rnorm(OBS, 0, 1)
## Generate outcome with effects
yInd <- (0.8 * Ind) + rnorm(OBS, 0, 1)
yCol <- (0.4 * Col) + rnorm(OBS, 0, 1)
## Generate id ##
ID <- matrix(1:OBS, ncol = 1)
## Create, save dataframe ##
TestData <- data.frame(ID, Treat, Pov, Ind, Col, Gen, Edu, Inc, yNull, yInd, yCol)
################
## Estimation ##
################
## Plain OLS ##
hypotheses <- c("Ind = 0", "Col = 1", "Ind - Col = 0")
equations <- c("yNull ~ Ind + Col", "yInd ~ Ind + Col", "yCol ~ Ind + Col")
for (h in hypotheses) {
RES <- matrix(nrow = 1, ncol = 5)
for (eqn in equations) {
# RES <- rbind(RES, RegTest(eqn, clustvars = TestData$ID, hypotheses = c(h), data = TestData))
RES <- rbind(RES, PermTest(eqn, treatvars = c("Treat"), clustvars = TestData$ID, hypotheses = c(h), iterations = 100, data = TestData))
}
RES <- RES[2:nrow(RES), 1:ncol(RES)]
RES <- cbind(RES, FDR(RES[, 4]))
rownames(RES) <- equations
colnames(RES)[6] <- "Min. Q"
print("--------------------------------------------------------------------", quote = FALSE)
print(paste("H_0:", h), quote = FALSE)
print(RES, quote = FALSE)
print("--------------------------------------------------------------------", quote = FALSE)
}
## Covariate adjustment ##
hypotheses <- c("Ind = 0") #, "Col = 1", "Ind - Col = 0")
equations <- c("yNull ~ Ind + Col + Gen + LnInc", "yInd ~ Ind + Col + Gen + LnInc", "yCol ~ Ind + Col + Gen + LnInc")
for (h in hypotheses) {
RES <- matrix(nrow = 1, ncol = 5)
for (eqn in equations) {
# RES <- rbind(RES, RegTest(eqn, clustvars = TestData$ID, hypotheses = c(h), data = TestData))
RES <- rbind(RES, PermTest(eqn, treatvars = c("Treat"), clustvars = TestData$ID, hypotheses = c(h), iterations = 1000, data = TestData))
}
RES <- RES[2:nrow(RES), 1:ncol(RES)]
RES <- cbind(RES, FDR(RES[, 4]))
rownames(RES) <- equations
colnames(RES)[6] <- "Min. Q"
print("--------------------------------------------------------------------", quote = FALSE)
print(paste("H_0:", h), quote = FALSE)
print(RES, quote = FALSE)
print("--------------------------------------------------------------------", quote = FALSE)
}
## Het effects ##
##############################
## Install missing packages ##
##############################
this.dir <- dirname(parent.frame(3)$ofile) # frame(3) also works.
setwd(this.dir)
set.seed(47269801)
required.packages <- c("dplyr", "multiwayvcov", "multcomp", "knitr", "rprojroot")
packages.missing <- required.packages[!required.packages %in% installed.packages()[,"Package"]]
if(length(packages.missing) > 0) {install.packages(required.packages, repo="https://cran.cnr.berkeley.edu/")}
lapply(required.packages, library, character.only = TRUE)
######################
## Define functions ##
######################
## RegTest conducts asymptotic test from linear model ##
RegTest <- function(equation, clustvars, hypotheses, data) {
model <- lm(equation, data = data, na.action = na.omit)
if (missing(clustvars)) model$vcov <- vcov(model)
else model$vcov <- cluster.vcov(model, cluster = clustvars)
model$test <- summary(glht(model, linfct = hypotheses, vcov = model$vcov))$test
numhyp <- length(hypotheses)
EST <- matrix(nrow = numhyp, ncol = 4)
for (i in 1:numhyp) {
EST[i, 1] <- model$test$coefficients[i]
EST[i, 2] <- model$test$tstat[i]
EST[i, 3] <- model$test$sigma[i]
EST[i, 4] <- model$test$pvalues[i]
}
colnames(EST) <- c("Estimate", "Tstat", "SE", "P")
return(EST)
}
## PermTest returns MC approximations of the exact p-value ##
PermTest <- function(equation, treatvars, clustvars, hypotheses, iterations, data) {
stopifnot(length(hypotheses) <= 1)
obsEST <- RegTest(equation, clustvars, hypotheses, data)
obsStat <- obsEST[1, 2]
simEST <- matrix(ncol = 4)
for (i in 1:iterations) {
simTreat <- data[, treatvars, drop = FALSE]
simTreat <- simTreat[sample(nrow(simTreat)),]
simData <- cbind(simTreat, data[, !(names(data) %in% treatvars), drop = FALSE])
colnames(simData)[1:2] <- treatvars
simEST <- rbind(simEST, RegTest(equation, clustvars, hypotheses, data = simData))
}
simSTAT <- simEST[2:nrow(simEST), 2]
countSTAT <- matrix(abs(simSTAT) >= abs(obsStat), ncol = 1)
ExactP <- matrix(1, nrow = 1, ncol = nrow(countSTAT)) %*% countSTAT
ExactP <- ExactP / iterations
EST <- cbind(obsEST, ExactP)
colnames(EST) <- c("Estimate", "Tstat", "SE", "P", "ExactP")
return(EST)
}
## FDR returns minimum q-values ##
FDR <- function(pvals, step) {
if (sum(is.na(pvals) == FALSE) <= 1) {return(pvals)}
if (missing(step)) {step <- 0.001}
allpvals <- cbind(as.matrix(pvals), matrix(1:nrow(as.matrix(pvals)), ncol = 1))
pvals <- na.omit(allpvals)
nump <- nrow(pvals)
pvals <- pvals[order(pvals[, 1]), ]
rank <- matrix(1:nump, ncol = 1)
pvals <- cbind(pvals, rank, matrix(0, nrow = nump, ncol = 1))
qval <- 1
while (qval > 0) {
qfirst <- qval / (1 + qval)
fdrtemp <- (qfirst * rank) / nump
subrank <- which(fdrtemp >= as.matrix(pvals[, 1]))
if (length(subrank) < 1) {
numreject <- 0
} else numreject <- max(subrank)
qsec <- qfirst * (nump / (nump - numreject))
fdrtemp <- (qsec * rank) / nump
subrank <- which(fdrtemp >= as.matrix(pvals[, 1]))
if (length(subrank) < 1) {
numreject <- 0
} else numreject <- max(subrank)
pvals[which(pvals[, 3] <= numreject), 4] <- qval
qval <- qval - step
}
pvals <- pvals[order(pvals[, 2]), ]
qvals <- matrix(nrow = nrow(allpvals), ncol = 1)
qvals[match(pvals[, 2], allpvals[, 2]), 1] <- pvals[, 4]
return(as.matrix(qvals))
}
################
## Clean data ##
################
## Create locals for simulation ##
OBS <- 510
## Generate treatment ##
Treat <- sample(0:2,OBS, rep = TRUE, prob = c(.33, .33, 0.33)) %>%
factor(levels = c(0, 1, 2), labels = c("Poverty", "Ind.", "Col."))
Pov <- (Treat == "Poverty") * 1
Ind <- (Treat == "Ind.") * 1
Col <- (Treat == "Col.") * 1
## Generate gender ##
Gen <- sample(0:1,OBS,rep = TRUE,prob = c(.5,.5))  %>%
factor(levels = c(0,1), labels = c("Male","Female"))
## Generate factor variable measuring highest level of education ##
Edu <- sample(1:3,OBS,rep = TRUE,prob = c(.5,.3,.2)) %>%
factor(levels = c(1,2,3), labels = c("Primary school","High school","University & above"))
## Generate income ##
LnInc <- rnorm(OBS, mean = 5, sd = 1)
Inc <- exp(LnInc)
## Generate y with notreatment effect ##
yNull <- rnorm(OBS, 0, 1)
## Generate outcome with effects
yInd <- (0.8 * Ind) + rnorm(OBS, 0, 1)
yCol <- (0.4 * Col) + rnorm(OBS, 0, 1)
## Generate id ##
ID <- matrix(1:OBS, ncol = 1)
## Create, save dataframe ##
TestData <- data.frame(ID, Treat, Pov, Ind, Col, Gen, Edu, Inc, yNull, yInd, yCol)
################
## Estimation ##
################
## Plain OLS ##
hypotheses <- c("Ind = 0", "Col = 1", "Ind - Col = 0")
equations <- c("yNull ~ Ind + Col", "yInd ~ Ind + Col", "yCol ~ Ind + Col")
for (h in hypotheses) {
RES <- matrix(nrow = 1, ncol = 5)
for (eqn in equations) {
# RES <- rbind(RES, RegTest(eqn, clustvars = TestData$ID, hypotheses = c(h), data = TestData))
RES <- rbind(RES, PermTest(eqn, treatvars = c("Treat"), clustvars = TestData$ID, hypotheses = c(h), iterations = 100, data = TestData))
}
RES <- RES[2:nrow(RES), 1:ncol(RES)]
RES <- cbind(RES, FDR(RES[, 4]))
rownames(RES) <- equations
colnames(RES)[6] <- "Min. Q"
print("--------------------------------------------------------------------", quote = FALSE)
print(paste("H_0:", h), quote = FALSE)
print(RES, quote = FALSE)
print("--------------------------------------------------------------------", quote = FALSE)
}
## Covariate adjustment ##
hypotheses <- c("Ind = 0") #, "Col = 1", "Ind - Col = 0")
equations <- c("yNull ~ Ind + Col + Gen + LnInc", "yInd ~ Ind + Col + Gen + LnInc", "yCol ~ Ind + Col + Gen + LnInc")
for (h in hypotheses) {
RES <- matrix(nrow = 1, ncol = 5)
for (eqn in equations) {
# RES <- rbind(RES, RegTest(eqn, clustvars = TestData$ID, hypotheses = c(h), data = TestData))
RES <- rbind(RES, PermTest(eqn, treatvars = c("Treat"), clustvars = TestData$ID, hypotheses = c(h), iterations = 1000, data = TestData))
}
RES <- RES[2:nrow(RES), 1:ncol(RES)]
RES <- cbind(RES, FDR(RES[, 4]))
rownames(RES) <- equations
colnames(RES)[6] <- "Min. Q"
print("--------------------------------------------------------------------", quote = FALSE)
print(paste("H_0:", h), quote = FALSE)
print(RES, quote = FALSE)
print("--------------------------------------------------------------------", quote = FALSE)
}
##############################
## Install missing packages ##
##############################
setwd("/Users/Justin/Google Drive/UBIF/UBIF_Deliverables/UBIF_PAP/K1_PAP")
set.seed(47269801)
required.packages <- c("dplyr", "multiwayvcov", "multcomp", "reshape2", "knitr")
packages.missing <- required.packages[!required.packages %in% installed.packages()[,"Package"]]
if(length(packages.missing) > 0) {install.packages(required.packages, repo="https://cran.cnr.berkeley.edu/")}
lapply(required.packages, library, character.only = TRUE)
######################
## Define functions ##
######################
## RegTest conducts asymptotic test from linear model ##
RegTest <- function(equation, clustvars, hypotheses, data) {
model <- lm(equation, data = data, na.action = na.omit)
if (missing(clustvars)) model$vcov <- vcov(model)
else model$vcov <- cluster.vcov(model, cluster = clustvars)
model$test <- summary(glht(model, linfct = hypotheses, vcov = model$vcov))$test
numhyp <- length(hypotheses)
EST <- matrix(nrow = numhyp, ncol = 4)
for (i in 1:numhyp) {
EST[i, 1] <- model$test$coefficients[i]
EST[i, 2] <- model$test$tstat[i]
EST[i, 3] <- model$test$sigma[i]
EST[i, 4] <- model$test$pvalues[i]
}
colnames(EST) <- c("Estimate", "Tstat", "SE", "P")
return(EST)
}
## PermTest returns MC approximations of the exact p-value ##
PermTest <- function(equation, treatvars, clustvars, hypotheses, iterations, data) {
stopifnot(length(hypotheses) <= 1)
obsEST <- RegTest(equation, clustvars, hypotheses, data)
obsStat <- obsEST[1, 2]
simEST <- matrix(ncol = 4)
for (i in 1:iterations) {
simTreat <- data[, treatvars, drop = FALSE]
simTreat <- simTreat[sample(nrow(simTreat)),]
simData <- cbind(simTreat, data[, !(names(data) %in% treatvars), drop = FALSE])
colnames(simData)[1:length(treatvars)] <- treatvars
simEST <- rbind(simEST, RegTest(equation, clustvars, hypotheses, data = simData))
}
simSTAT <- simEST[2:nrow(simEST), 2]
countSTAT <- matrix(abs(simSTAT) >= abs(obsStat), ncol = 1)
ExactP <- colSums(countSTAT) / iterations
EST <- cbind(obsEST, ExactP)
colnames(EST) <- c("Estimate", "Tstat", "SE", "P", "ExactP")
return(EST)
}
## FDR returns minimum q-values ##
FDR <- function(pvals, step) {
if (sum(is.na(pvals) == FALSE) <= 1) {return(pvals)}
if (missing(step)) {step <- 0.001}
allpvals <- cbind(as.matrix(pvals), matrix(1:nrow(as.matrix(pvals)), ncol = 1))
pvals <- na.omit(allpvals)
nump <- nrow(pvals)
pvals <- pvals[order(pvals[, 1]), ]
rank <- matrix(1:nump, ncol = 1)
pvals <- cbind(pvals, rank, matrix(0, nrow = nump, ncol = 1))
qval <- 1
while (qval > 0) {
qfirst <- qval / (1 + qval)
fdrtemp <- (qfirst * rank) / nump
subrank <- which(fdrtemp >= as.matrix(pvals[, 1]))
if (length(subrank) < 1) {
numreject <- 0
} else numreject <- max(subrank)
qsec <- qfirst * (nump / (nump - numreject))
fdrtemp <- (qsec * rank) / nump
subrank <- which(fdrtemp >= as.matrix(pvals[, 1]))
if (length(subrank) < 1) {
numreject <- 0
} else numreject <- max(subrank)
pvals[which(pvals[, 3] <= numreject), 4] <- qval
qval <- qval - step
}
pvals <- pvals[order(pvals[, 2]), ]
qvals <- matrix(nrow = nrow(allpvals), ncol = 1)
qvals[match(pvals[, 2], allpvals[, 2]), 1] <- pvals[, 4]
return(as.matrix(qvals))
}
################
## Clean data ##
################
varnames <- as.vector(read.delim(file = "K1__Field_Survey_v34+35_Appended.csv", sep = ",", header = FALSE, stringsAsFactors = FALSE, na.strings = "", nrows = 1))
k1_df <- read.delim(file = "K1__Field_Survey_v34+35_Appended.csv", sep = ",", header = FALSE, stringsAsFactors = FALSE, na.strings = "", skip = 2, nrows = 600, col.names = varnames)
attach(k1_df)
## Survey meta data ##
k1_df$start.time.mst <- as.POSIXct(as.character(k1_df$V3), format = "%m/%d/%y %H:%M")
k1_df$start.time.eat <- k1_df$start.time.mst + (60 * 60 * 9)
k1_df$end.time.mst <- as.POSIXct(as.character(k1_df$V4), format = "%m/%d/%y %H:%M")
k1_df$end.time.eat <- k1_df$end.time.mst + (60 * 60 * 9)
View(k1_df)
is.character(V1)
duplicated(V1)
nonentry <- c("R_5ZkChbiXDIj6KsK", "R_7N8rNtLsxF5a9on", "R_97Tx2cAjy30fqMR", "R_lYnRvOAJhuax6LS", "R_8dky4iSC7rfEuNc", "R_nczo7KPxLkkKkgo", "R_5j1OiNu3wMp265N", "R_0GYX0scNN16ICfQ", "R_6PoFtAhwvSBNYzi", "R_696kAyWai9bDkFI", "R_hPaLwAaYCnY0l69", "R_oGNBAVexMWYhMml", "R_3rwTGdEULwOGH2y", "R_bhNv0SnArTa32Xe", "R_5txHVIbQY6twLIZ", "R_kaSM6nunZ9Ynatj", "R_0ppcidBVCPaEkXK", "R_oWceQFJG5NnSokN", "R_h5Cw4tvVUeDY8NI", "R_9ib4ASBi450NZPt", "R_mAlfPdxj5GQsJF5", "R_kbW6NDTS1FWXyn3", "R_b1GC7jpoQrJKrFN", "R_5YpNpbPWOxnSNWc", "R_mwLFSjScVyrgs9J", "R_1jbOtmMIrvgTgaE", "R_if5tz3h1N9MzTp2", "R_aFmo1jRrWIwsLjI", "R_2itxVUcUstO3Syp", "R_9LP4exOnWpJ1TrE", "R_cQLu9PDCtFwbn7K", "R_oFl39knSVL3SKpz", "R_11Y1KTzawxBJmvy")
k1_df <- k1_df[! k1_df$survey.id %in% nonentry, ]
